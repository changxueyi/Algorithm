##场景题

###问题一：让你设计一个微信发红包的api，你会怎么设计，不能有人领到的红包里面没钱，红包数值精确到分。

传入参数有总钱数，分的份数，随机分还是等分。先判断钱数能不能分那么多份，这个直接用总钱数>=0.01*份数判断就
可以了。然后根据分发策略，选择随机还是等分，随机的话就给 1到总钱数-（总份数-1）*0.01 的随机数（总钱数以分为
单位），等分的话直接除判断能不能除开，有余数就将余数加到最后一份里面

###问题二：谁关注了我，我关注了谁，谁与我互相关注。表该如何设计，索引怎么建。查询语句怎么写
粉丝关注表使用四列，主键id，userId，fansId，是否互相关注。
用两行数据来保存互相的关注关系，这样查询起来更方便，用空间换时间。
主键有主键索引，剩下的字段不适合建索引，因为字段重复太多。

###场景题，分布式多个机器生成id，如何保证不重复?
1.snowflake方案：
snowflake是Twitter开源的分布式ID生成算法，结果是一个long型的ID。其核心思想是：使用41bit作为毫秒数，10bit作为机器的ID（5个bit是数据中心，5个bit的机器ID），12bit作为毫秒内的流水号（意味着每个节点在每毫秒可以产生 4096 个 ID），最后还有一个符号位，永远是0。
优点：
1.毫秒数在高位，自增序列在低位，整个ID都是趋势递增的。
2.不依赖数据库等第三方系统，以服务的方式部署，稳定性更高，生成ID的性能也是非常高的。
3.可以根据自身业务特性分配bit位，非常灵活。
缺点：
强依赖机器时钟，如果机器上时钟回拨，会导致发号重复或者服务会处于不可用状态。


2.用Redis生成ID：
因为Redis是单线程的，也可以用来生成全局唯一ID。可以用Redis的原子操作INCR和INCRBY来实现。
此外，可以使用Redis集群来获取更高的吞吐量。假如一个集群中有5台Redis，可以初始化每台Redis的值分别是1,2,3,4,5，步长都是5，各Redis生成的ID如下：
A：1,6,11,16
B：2,7,12,17
C：3,8,13,18
D：4,9,14,19
E：5,10,15,20
这种方式是负载到哪台机器提前定好，未来很难做修改。3~5台服务器基本能够满足需求，都可以获得不同的ID，但步长和初始值一定需要事先确定，使用Redis集群也可以解决单点故障问题。
另外，比较适合使用Redis来生成每天从0开始的流水号，如订单号=日期+当日自增长号。可以每天在Redis中生成一个Key，使用INCR进行累加。
优点：
1）不依赖于数据库，灵活方便，且性能优于数据库。
2）数字ID天然排序，对分页或需要排序的结果很有帮助。
缺点：
1）如果系统中没有Redis，需要引入新的组件，增加系统复杂度。
2）需要编码和配置的工作量较大。

###LRU算法知道吗，怎么实现的?
LRU算法：最近最少使用算法，常用于进程调度，缓存淘汰，内存页面置换等场景。
使用LinkedHashMap可以实现，相对于HashMap,增加了双向链表，用于记录节点之间的先后顺序。
LinkedHashMap的构造函数提供了一个参数accessOrder，这个参数可以指定链表是按照插入顺序排队
还是按照访问顺序排队。参数为true时，就是按照访问顺序（插入，查询）排队，每次访问后这个节点就会被放到链表头，
而长时间不被访问的节点逐渐就到了列表尾部，当需要淘汰时，就将链表尾部的节点抛弃。



###数据库连接池怎么设计?
需要考虑的问题：
限制连接池中最多、可以容纳的连接数目，避免过度消耗系统资源。
当客户请求连接，而连接池中所有连接都已被占用时，该如何处理呢？一种方式是让客户一直等待，直到有空闲连接，另一种方式是为客户分配一个新的临时连接。
当客户不再使用连接，需要把连接重新放回连接池。
连接池中允许处于空闲状态的连接的最大项目。假定允许的最长空闲时间为十分钟，并且允许空闲状态的连接最大数目为5，
那么当连接池中有n个(n>5)连接处于空闲状态的时间超过十分钟时，就应该把n-5个连接关闭，并且从连接池中删除，这样才能更有效的利用系统资源。

###扫码登录是如何实现的？
https://blog.csdn.net/j3T9Z7H/article/details/106009662


###B+树和红黑树
红黑树和一般的平衡二叉树，增、删、改、查的过程和效率、时间复杂度
https://www.cnblogs.com/ArleneZhangfj/articles/10067570.html

##大数据类场景题
###1亿个正整数,范围是0-42亿。求出现次数是2的数字，空间复杂度
使用位图bitMap。位图是以bit位为单位进行数据存储，这样每个字节8个位就可以存储8个数字，
普通的一个int占4个字节，32位，用了位图之后可以将空间节省32倍。
开一个42亿大小的位图，将这一亿个数字存进数字大小对应的位置，一个bit每存进去一个数字，就将value+1,
比如第一次存8，就将索引为8的位置的value置为1，第二次就置为2，存完之后搜索value为2的key是多少。
32位机器最大能表示的数字是42亿9千多万。
42亿bit /(8*1024*1024) = 500MB


###算法：有一个IP地址库，假设有几十万条ip，如何判断某个ip地址是否在这个库中？
思路一：分治法，将ip地址根据前三位分成256份，然后看这个ip地址对应的网段，只比对这个网段里面是否有这个ip，当然还可以继续分下去，根据数据量来决定分成多少份。
思路二：位图，将每一条ip对应位图中的一个位，2^32次方(42亿多)个数据只需要512M空间。可以实现O(1)的时间搜索，O(n)的时间存储。

###场景题：2g内存，要求一个10g文件的中位数
http://blog.sina.com.cn/s/blog_8e9c63c70101f5pl.html

###带权重抽奖：100万个人，100个奖品，每个人中奖倍率不同，抽完为止，每人最多中奖一次。
(面经中给的解释：先用古典概型写了一个：基础中奖几率*中奖倍率，但是这样做对前面的人有优势，
于是重新思考后用几何概型写了一个，List表示线段，List中存对应人的id。）

###情景题，一个5T的文件，里面全是id，1-10^9 ，如何计算不同id的个数？
哈希到不同的文件，再逐个文件内找不同的。
